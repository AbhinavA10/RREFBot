[1mdiff --git a/scanningTest.c b/scanningTest.c[m
[1mindex 92a33cf..0c7e989 100644[m
[1m--- a/scanningTest.c[m
[1m+++ b/scanningTest.c[m
[36m@@ -1,8 +1,7 @@[m
[31m-const float DIST_CONV=180/(2.75*PI);[m
[31m-[m
[31m-const int AXIAL = motorB;[m
[32m+[m[32mconst int BACK_WHEELS = motorB;[m
 const int SWEEPER = motorA;[m
 const int COLOR_SENS=S2;[m
[32m+[m[32mconst float WHEEL_RADIUS = 2.75[m
 [m
 const float WIDTH = 1.5; // x distance between each pixel[m
 const float HEIGHT = 0.75;[m
[36m@@ -72,38 +71,49 @@[m [mbool Digit6[9][5] = {[m
 						{0, 0, 0, 0, 0},[m
 						{0, 0, 0, 0, 0}	};[m
 [m
[31m-float getSweepDistance(int angle){[m
[31m-	// after modelling the data as[m
[31m-	return (0.2995578422*angle+ 0.844450546);[m
[32m+[m[32mfloat getEncCountFromWheelDist(float distance){[m
[32m+[m	[32mreturn distance * (180.0/(WHEEL_RADIUS*PI));[m
[32m+[m[32m}[m
[32m+[m[32mfloat getWheelDistFromEncCount(double count){[m
[32m+[m	[32mreturn count / (180.0/(WHEEL_RADIUS*PI));[m
 }[m
 [m
[32m+[m
 void nextPixelRight(){[m
 	motor[SWEEPER]=70;[m
 	nMotorEncoder[SWEEPER]=0;[m
[31m-	// range of angle thing [m
[31m-	//goes from 0.844 to 1.5[m
[31m-	// each 5 degrees moves it 1.5cm[m
[31m-	while(getSweepDistance(nMotorEncoder[SWEEPER]) < 1.5+0.844){}[m
[32m+[m	[32m// insert function too convert wheel rope to linear distance[m
 	motor[SWEEPER]=0;[m
 }[m
 void nextPixelLeft(){[m
 	motor[SWEEPER]=-70;[m
 	nMotorEncoder[SWEEPER]=0;[m
[31m-	// range of angle thing [m
[32m+[m	[32m// range of angle thing[m
 	//goes from 0.844 to 1.5[m
 	while(getSweepDistance(nMotorEncoder[SWEEPER]) > 0.844-1.5){}[m
 	motor[SWEEPER]=0;[m
 }[m
[31m-void nextLine(){[m
[31m-	motor[AXIAL]=20;[m
[31m-	nMotorEncoder[AXIAL]=0;[m
[31m-	while(nMotorEncoder[AXIAL]/DIST_CONV < HEIGHT){}[m
[31m-	motor[SWEEPER]=0;[m
[32m+[m[32mvoid moveRobotDown(int distanceDown, bool down){[m
[32m+[m	[32mnMotorEncoder[BACK_WHEELS] = 0;[m
[32m+[m	[32mif(down){[m
[32m+[m		[32mmotor[BACK_WHEELS] = 10;[m
[32m+[m		[32m// moves down for specified distance[m
[32m+[m		[32mwhile(nMotorEncoder[BACK_WHEELS]<=(getEncCountFromWheelDist(distanceDown))){}[m
[32m+[m		[32mmotor[BACK_WHEELS] = 0;[m
[32m+[m	[32m}[m
[32m+[m		[32m// moving up[m
[32m+[m	[32melse{[m
[32m+[m		[32mmotor[BACK_WHEELS] = -10;[m
[32m+[m		[32m// moves down for specified distance[m
[32m+[m		[32mwhile(nMotorEncoder[BACK_WHEELS]>=((getEncCountFromWheelDist(distanceDown)))*-1){}[m
[32m+[m		[32mmotor[BACK_WHEELS] = 0;[m
[32m+[m	[32m}[m
 }[m
[32m+[m
 void goLeft(){[m
 	motor[SWEEPER]=-50;[m
[31m-	nMotorEncoder[AXIAL]=0;[m
[31m-	while(nMotorEncoder[AXIAL] > (-1)*ANGLE_SPAN){}[m
[32m+[m	[32mnMotorEncoder[SWEEPER]=0;[m
[32m+[m	[32mwhile(nMotorEncoder[SWEEPER] > (-1)*ANGLE_SPAN){}[m
 	motor[SWEEPER]=0;[m
 }[m
 void outputMatrix(){[m
[36m@@ -147,12 +157,12 @@[m [mtask main(){[m
 					Digit6[row][column-10]=isBlack;[m
 				}[m
 			}[m
[31m-			nextPixelRight(); // horizontal[m
[32m+[m			[32m//nextPixelRight(); // horizontal[m
 [m
[31m-			//nextPixelLeft(); // horizontal[m
[32m+[m			[32mnextPixelLeft(); // horizontal[m
 			wait1Msec(1000);[m
 		}[m
[31m-		nextLine();[m
[32m+[m		[32mmoveRobotDown(HEIGHT, 1);[m
 		wait1Msec(1000);[m
 	}[m
 	outputMatrix();[m
